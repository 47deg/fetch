<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=""> <![endif]--><!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8" lang=""> <![endif]--><!--[if IE 8]>         <html class="no-js lt-ie9" lang=""> <![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="">
<!--<![endif]-->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Fetch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="apple-touch-icon" href="%5BINSERT%20apple-tuch-icon.png%5D">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/tomorrow.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link href="https://rawgit.com/47deg/microsites/cdn/style.css" rel="stylesheet">
</head>

<body class="docs">
  <!--[if IE]>
    <script src="https://cdn.jsdelivr.net/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://cdn.jsdelivr.net/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  <div id="wrapper">
    <div id="sidebar-wrapper">
      <ul id="sidebar" class="sidebar-nav">
        <li class="sidebar-brand">
          <a href="#" data-href="/fetch/">
            <div class="brand-wrapper" style="background:url('https://rawgit.com/47deg/microsites/cdn/fetch/sidebar_brand.png') no-repeat">
              <span>Fetch</span>
            </div>
          </a>
        </li>
      </ul>
    </div>
    <div id="page-content-wrapper">
      <div class="nav">
        <div class="container-fluid">
          <div class="row">
            <div class="col-lg-12">
              <div class="action-menu pull-left clearfix">
                <a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a>
              </div>
              <ul class="pull-right">
                <li class="hidden-xs"><a href="#" data-href="https://github.com/47deg/fetch"><i class="fa fa-eye"></i><span>WATCH (<m id="eyes">--</m>)</span></a></li>
                <li class="hidden-xs"><a href="#" data-href="https://github.com/47deg/fetch"><i class="fa fa-star-o"></i><span>STARS (<m id="stars">--</m>)</span></a></li>
                <li><a href="#" onclick="shareSiteTwitter();"><i class="fa fa-twitter"></i></a></li>
                <li><a href="#" onclick="shareSiteFacebook();"><i class="fa fa-facebook"></i></a></li>
                <li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <!--Heading-->
      <div id="content"><h1>Introduction</h1>

<p>Oftentimes, our applications read and manipulate data from a variety of
different sources such as databases, web services or file systems. These data
sources are subject to latency, and we&#39;d prefer to query them efficiently.</p>

<p>If we are just reading data, we can make a series of optimizations such as:</p>

<ul>
<li>batching requests to the same data source</li>
<li>requesting independent data from different sources in parallel</li>
<li>caching previously seen results</li>
</ul>

<p>However, if we mix these optimizations with the code that fetches the data
we may end up trading clarity for performance. Furthermore, we are
mixing low-level (optimization) and high-level (business logic with the data
we read) concerns.</p>

<p>Fetch is a library that allows your data fetches to be written in a concise,
composable way while executing efficiently. You don&#39;t need to use any explicit
concurrency construct but existing idioms: applicative for concurrency and
monad for sequencing.</p>

<h1>Installation</h1>

<p>First of all, add the following dependency to your SBT build file:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="s">"org.fortysevendeg"</span> <span class="o">%%%</span> <span class="s">"fetch"</span> <span class="o">%</span> <span class="s">"0.1.0"</span>
</code></pre></div>
<p>Now you&#39;ll have Fetch available both in Scala and Scala.js.</p>

<h1>Usage</h1>

<p>In order to tell Fetch how to retrieve data, we must implement the <code>DataSource</code> typeclass.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]{</span>
  <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Identity</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div>
<p>It takes two type parameters:</p>

<ul>
<li><code>Identity</code>: the identity we want to fetch (a <code>UserId</code> if we were fetching users)</li>
<li><code>Result</code>: the type of the data we retrieve (a <code>User</code> if we were fetching users)</li>
</ul>

<p>The <code>fetch</code> method takes a non empty list of identities and must return an <code>Eval</code> that will result
in a map from identities to results. Accepting a list of identities gives Fetch the ability to batch requests to
the same data source, and returning a mapping from identities to results Fetch can detect whenever an identity
couldn&#39;t be fetched or no longer exists.</p>

<p>Returning <code>Eval</code> makes it possible to defer evaluation with a concurrency monad when running a fetch. For example
when using <code>Future</code> as your target monad when running a fetch the data source fetches will possibly run in a thread pool,
depending on the implicit execution context you use.</p>

<h2>Writing your first data source</h2>

<p>Now that we know about the <code>DataSource</code> typeclass, let&#39;s write our first data source! We&#39;ll be using Scala&#39;s
<code>Future</code> as our concurrency monad for the examples. We&#39;ll write a little function for simulating latency and
another for blocking on futures to get their results. Note that the <code>Future</code> API differs in Scala and Scala.js,
since there are no threads in JavaScript and you cannot block for a <code>Future</code>&#39;s result.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.util.Random</span>
<span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="k">import</span> <span class="nn">cats.Eval</span>

<span class="k">def</span> <span class="n">latency</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">result</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wait</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">))</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Eval</span><span class="o">.</span><span class="n">later</span><span class="o">({</span>
    <span class="k">val</span> <span class="n">threadId</span> <span class="k">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">currentThread</span><span class="o">().</span><span class="n">getId</span><span class="o">()</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"~~~&gt;[thread: $threadId] $msg"</span><span class="o">)</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="n">wait</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"&lt;~~~[thread: $threadId] $msg"</span><span class="o">)</span>
    <span class="n">result</span>
  <span class="o">})</span>

<span class="k">def</span> <span class="n">await</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
</code></pre></div>
<p>We&#39;ll start implementing a data source for fetching users given their id. The identity type will be a user&#39;s
id and the result type a user.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">fetch._</span>

<span class="k">type</span> <span class="kt">UserId</span> <span class="o">=</span> <span class="nc">Int</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">,</span> <span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">object</span> <span class="nc">UserSource</span> <span class="k">extends</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">UserId</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">UserId</span>, <span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">User</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="s">"@egg_$i"</span><span class="o">))).</span><span class="n">toMap</span>
    <span class="n">latency</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">s</span><span class="s">"Fetching users $ids"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Now that we have a data source we can write a function for fetching users
given an id, we just have to pass a <code>UserId</code> as an argument to <code>Fetch</code>.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getUser</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="c1">// or, more explicitly: Fetch(id)(UserSource)
</span></code></pre></div>
<h2>Declaring and running a fetch</h2>

<p>We are now ready to declare and run fetches, the only thing missing is an instance
of <code>MonadError[M, Throwable]</code> for our target monad (<code>scala.concurrent.Future</code>), which
the <code>cats</code> library already provides.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.std.future._</span>

<span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 43] Fetching users List(1)
// &lt;~~~[thread: 43] Fetching users List(1)
</span>
<span class="c1">//=&gt; User(1,@egg_1)
</span></code></pre></div>
<p>In the previous example, we:</p>

<ul>
<li>brought the implicit instance of <code>MonadError[Future, Throwable]</code> into scope importing <code>cats.std.future._</code></li>
<li>created a fetch for a <code>User</code> using the <code>getUser</code> function</li>
<li>interpreted the fetch to a <code>Future</code> using <code>Fetch.run</code></li>
</ul>

<p>As you can see, the fetch was executed only in one round to fetch the user and was finished after that.</p>

<h3>Sequencing</h3>

<p>When we have two fetches that depend on each other, we can use <code>flatMap</code> to combine them. When composing fetches with <code>flatMap</code> we are telling Fetch that the second one depends on the previous one, so it isn&#39;t able to make any optimizations.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">aUser</span> <span class="k">&lt;-</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">anotherUser</span> <span class="k">&lt;-</span> <span class="n">getUser</span><span class="o">(</span><span class="n">aUser</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">aUser</span><span class="o">,</span> <span class="n">anotherUser</span><span class="o">)</span>

<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 44] Fetching users List(1)
// &lt;~~~[thread: 44] Fetching users List(1)
// ~~~&gt;[thread: 42] Fetching users List(2)
// &lt;~~~[thread: 42] Fetching users List(2)
</span>
<span class="c1">//=&gt; (User(1,@egg_1),User(2,@egg_2))
</span></code></pre></div>
<h3>Batching</h3>

<p>If we combine two independent requests to the same data source, Fetch will
automatically batch them together into a single request. Fetch&#39;s <code>join</code> operator
help us tell the library that two fetches are independent, and thus can be batched
if they use the same data source:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 47] Fetching users List(1, 2)
// &lt;~~~[thread: 47] Fetching users List(1, 2)
</span>
<span class="c1">//=&gt; (User(1,@egg_1),User(2,@egg_2))
</span></code></pre></div>
<h3>Deduplication</h3>

<p>If two independent requests ask for the same identity, Fetch will detect that and
deduplicate such id.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 47] Fetching users List(1)
// &lt;~~~[thread: 47] Fetching users List(1)
</span>
<span class="c1">//=&gt; (User(1,@egg_1),User(1,@egg_1))
</span></code></pre></div>
<h3>Caching</h3>

<p>During a fetch, previously requested results are implicitly cached. This allows us to write
fetches in a very modular way, asking for all the data they need as if it
was in memory; furthermore, it also avoids refetching an identity that may have changed
during the course of a fetch execution, which can lead to inconsistencies in the data.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">aUser</span> <span class="k">&lt;-</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">anotherUser</span> <span class="k">&lt;-</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">aUser</span><span class="o">,</span> <span class="n">anotherUser</span><span class="o">)</span>

<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">User</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 53] Fetching users List(1)
// &lt;~~~[thread: 53] Fetching users List(1)
</span>
<span class="c1">//=&gt; (User(1,@egg_1),User(1,@egg_1))
</span></code></pre></div>
<p>As you can see, the <code>User</code> with id 1 was fetched only once in a single round-trip. The next
time it was needed we used the cached versions, thus avoiding another request to the user data
source.</p>

<h2>Combining data from multiple sources</h2>

<p>Now that we know about some of the optimizations that Fetch can make to read data efficiently,
let&#39;s look at how we can combine more than one data source. Imagine that we are rendering a blog
and have the following types for posts and post information:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">PostId</span> <span class="o">=</span> <span class="nc">Int</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Post</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">,</span> <span class="n">author</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">,</span> <span class="n">content</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">PostInfo</span><span class="o">(</span><span class="n">topic</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></div>
<p>As you can see, every <code>Post</code> has an author, but it refers to it by its id. We&#39;ll implement two data sources:</p>

<ul>
<li>one for retrieving a post given a post id</li>
<li>another for retrieveng post metadata given a post id</li>
</ul>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">implicit</span> <span class="k">object</span> <span class="nc">PostSource</span> <span class="k">extends</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">PostId</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">Post</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">Post</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">s</span><span class="s">"An article with id $i"</span><span class="o">))).</span><span class="n">toMap</span>
    <span class="n">latency</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">s</span><span class="s">"Fetching posts $ids"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">getPost</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">Post</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">object</span> <span class="nc">PostInfoSource</span> <span class="k">extends</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">PostInfo</span><span class="o">]{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">PostId</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">PostId</span>, <span class="kt">PostInfo</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">PostInfo</span><span class="o">(</span><span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="s">"applicative"</span> <span class="k">else</span> <span class="s">"monad"</span><span class="o">))).</span><span class="n">toMap</span>
    <span class="n">latency</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">s</span><span class="s">"Fetching post info $ids"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">getPostInfo</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">PostId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">PostInfo</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</code></pre></div>
<p>We can also implement a function for fetching a post&#39;s author given a post:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getAuthor</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Post</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">author</span><span class="o">)</span>
</code></pre></div>
<p>Now that we have multiple sources, let&#39;s mix them in the same fetch.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">post</span> <span class="k">&lt;-</span> <span class="n">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">user</span> <span class="k">&lt;-</span> <span class="n">getAuthor</span><span class="o">(</span><span class="n">post</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">post</span><span class="o">,</span> <span class="n">user</span><span class="o">)</span>

<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 81] Fetching posts List(1)
// &lt;~~~[thread: 81] Fetching posts List(1)
// ~~~&gt;[thread: 82] Fetching users List(2)
// &lt;~~~[thread: 82] Fetching users List(2)
</span>
<span class="c1">//=&gt; (Post(1,2,An article with id 1),User(2,@egg_2))
</span></code></pre></div>
<p>In the previous example we fetched a post given its id, and then fetched its author. These
data could come from entirely different places but Fetch makes working with heterogeneous sources
of data very easy.</p>

<h3>Parallelism</h3>

<p>Combining multiple independent requests to the same data source results in batching but what happens
when combining independent requests to <em>different</em> data sources? We have the oportunity to query the
different data sources at the same time.</p>

<p>Since we are using <code>Future</code> as our concurrency monad, the requests will effectively run in parallel,
each in its own thread.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 83] Fetching posts List(1)
// ~~~&gt;[thread: 84] Fetching users List(2)
// &lt;~~~[thread: 84] Fetching users List(2)
// &lt;~~~[thread: 83] Fetching posts List(1)
</span>
<span class="c1">//=&gt; (Post(1,2,An article with id 1),User(2,@egg_2))
</span></code></pre></div>
<p>As you can notice, both requests are started at the same time in different threads (with ids 83 and 84) and
the fetch finishes as soon as both results are available.</p>

<h2>Combinators</h2>

<p>Besides <code>flatMap</code> for sequencing fetches and <code>join</code> for running them concurrently, Fetch provides a number of
other combinators that you can use.</p>

<h3>Collect</h3>

<p>Whenever we have a list of fetches of the same type and want to run them concurrently we can use the <code>collect</code>
combinator. It takes a <code>List[Fetch[A]]</code> and gives you back a <code>Fetch[List[A]]</code>, batching the fetches to the same
data source and running fetches to different sources in parallel.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>

<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 86] Fetching users List(1, 2, 3)
// &lt;~~~[thread: 86] Fetching users List(1, 2, 3)
</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span></code></pre></div>
<p>As you can see, requests to the user data source were batched, thus fetching all the data in one round.</p>

<h3>Traverse</h3>

<p>Another interesing combinator is <code>traverse</code>, which is the composition of <code>map</code> and <code>collect</code>.a</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))(</span><span class="n">getUser</span><span class="o">)</span>

<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 86] Fetching users List(1, 2, 3)
// &lt;~~~[thread: 86] Fetching users List(1, 2, 3)
</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span></code></pre></div>
<h1>Caching</h1>

<p>As we have learned, Fetch caches intermediate results implicitly using a cache. You can
provide a prepopulated cache for running a fetch, replay a fetch with the cache of a previous
one and even implement a custom cache.</p>

<h2>Prepopulating a cache</h2>

<p>We&#39;ll be using the default in-memory cache, prepopulated with some data. The cache key of an identity
is calculated with the <code>DataSource</code>&#39;s <code>identity</code> method; we can pass a cache as the second argument when
running a fetch with <code>Fetch.run</code>.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="nc">InMemoryCache</span><span class="o">(</span><span class="nc">UserSource</span><span class="o">.</span><span class="n">identity</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"@dialelo"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">,</span> <span class="n">cache</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">//=&gt; User(1,@dialelo)
</span></code></pre></div>
<p>As you can see, when all the data is cached no fetch is executed at all since the results are available
in the cache.</p>

<p>If only part of the data is cached, the cached data won&#39;t be asked for:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))(</span><span class="n">getUser</span><span class="o">)</span>
<span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="nc">InMemoryCache</span><span class="o">(</span><span class="nc">UserSource</span><span class="o">.</span><span class="n">identity</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"@two"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">,</span> <span class="n">cache</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 180] Fetching users List(1, 3)
// &lt;~~~[thread: 180] Fetching users List(1, 3)
</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@two), User(3,@egg_3))
</span></code></pre></div>
<h2>Replaying a fetch</h2>

<p>When running a fetch we are generally interested in its final result. However, we also have access to the cache
and information about the executed rounds once we run a fetch. Fetch&#39;s interpreter keeps its state in an environment
(implementing the <code>Env</code> trait) and we can get both the environment and result after running a fetch using <code>Fetch.runFetch</code>
instead of <code>Fetch.run</code>.</p>

<p>Knowing this, we can replay a fetch reusing the cache of a previous one. The replayed fetch won&#39;t have to call any of the
data sources.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))(</span><span class="n">getUser</span><span class="o">)</span>
<span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="n">await</span><span class="o">(</span><span class="nc">Fetch</span><span class="o">.</span><span class="n">runEnv</span><span class="o">[</span><span class="kt">Future</span><span class="o">](</span><span class="n">fch</span><span class="o">))</span>
<span class="c1">// ~~~&gt;[thread: 261] Fetching users List(1, 2, 3)
// &lt;~~~[thread: 261] Fetching users List(1, 2, 3)
</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">,</span> <span class="n">env</span><span class="o">.</span><span class="n">cache</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span></code></pre></div>
<h2>Implementing a custom cache</h2>

<p>The default cache is implemented as an in-memory map, but users are free to use their own caches when running a fetch. Your cache should implement the <code>DataSourceCache</code> trait, and after that you can pass it to Fetch&#39;s <code>run</code> methods.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">DataSourceCache</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">DataSourceIdentity</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">DataSourceCache</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">I</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">DataSourceIdentity</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div>
<p>Let&#39;s reimplement the in memory cache found in Fetch, we&#39;ll write a case class that&#39;ll store the cache contents in an in-memory immutable map and implement <code>DataSourceCache</code>.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">MyInMemoryCache</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">DataSourceIdentity</span>, <span class="kt">Any</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DataSourceCache</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">I</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">DataSourceIdentity</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">update</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">DataSourceIdentity</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">MyInMemoryCache</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span><span class="n">state</span> <span class="k">=</span> <span class="n">state</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div>
<p>Now that we have a data type, we can use it when running a fetch:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="nc">MyInMemoryCache</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="nc">UserSource</span><span class="o">.</span><span class="n">identity</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">User</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"dialelo"</span><span class="o">)))</span>
<span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">,</span> <span class="n">cache</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">//=&gt; User(1,dialelo)
</span></code></pre></div>
<h1>Error handling</h1>

<p>You probably have noticed that <code>DataSource.fetch</code> takes a list of identities and returns a map of identities to their result, taking
into account the possibility of some identities not being found. Whenever an identity isn&#39;t found, the fetch execution will
fail.</p>

<h2>Diagnosing fetch failures</h2>

<p>Whenever a fetch fails, a <code>FetchFailure</code> exception is thrown. The <code>FetchFailure</code> will have the environment, which gives you information about the execution of a fetch.</p>

<p>We plan to make error handling more flexible in the future, as well as providing combinators for retrying fetches, timeouts and so on.</p>

<h1>Syntax</h1>

<h2>cats</h2>

<p>Fetch is built using cats&#39; Free monad construction and thus works out of the box with
cats syntax. Using cats&#39; syntax we can make fetch declarations more concise, without
the need to use the combinators in the <code>Fetch</code> companion object.</p>

<h3>Apply</h3>

<p>The <code>|@|</code> operator allow us to combine multiple independent fetches, even when they
are from different types, and apply a pure function to their results. We can use it
as a more powerful alternative to <code>Fetch.join</code>:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.syntax.cartesian._</span>

<span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="o">(</span><span class="n">getPost</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="n">tupled</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">Post</span>, <span class="kt">User</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 92] Fetching posts List(1)
// ~~~&gt;[thread: 93] Fetching users List(2)
// &lt;~~~[thread: 92] Fetching posts List(1)
// &lt;~~~[thread: 93] Fetching users List(2)
</span>
<span class="c1">//=&gt; (Post(1,2,An article with id 1),User(2,@egg_2))
</span></code></pre></div>
<p>More interestingly, we can use it to apply a pure function to the results of various
fetches.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.syntax.cartesian._</span>

<span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="n">map</span><span class="o">({</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">other</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">s</span><span class="s">"${one.username} is friends with ${other.username}"</span>
<span class="o">})</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 56] Fetching users List(1, 2)
// &lt;~~~[thread: 56] Fetching users List(1, 2)
</span>
<span class="c1">//=&gt; @egg_1 is friends with @egg_2
</span></code></pre></div>
<h3>Traverse</h3>

<p>Apart from using Fetch with cartesian syntax and performing all fetches in a product concurrently, we can treat Fetch as an applicative and get implicit concurrency and batching as well.</p>

<p>For the next example, we&#39;ll import cats&#39; extensions to the <code>List</code> type and traverse syntax. This will allow us to use both <code>sequence</code> and <code>traverse</code> methods on lists, which are equivalent to <code>Fetch#collect</code> and <code>Fetch#traverse</code>.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.std.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.traverse._</span>
</code></pre></div>
<p>We&#39;ll start by using <code>sequence</code>, which can transform <code>List[Fetch[A]]</code> to a <code>Fetch[List[A]]</code>.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">getUser</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="n">getUser</span><span class="o">(</span><span class="mi">3</span><span class="o">)).</span><span class="n">sequence</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 65] Fetching users List(1, 2, 3)
// &lt;~~~[thread: 65] Fetching users List(1, 2, 3)
</span>
<span class="c1">//=&gt; List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span></code></pre></div>
<p>Next is <code>traverse</code>, which traverses a collection with a fetch-returning function and collapses the result into a fetch of a collection.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">fch</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">traverse</span><span class="o">(</span><span class="n">getUser</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fut</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">fch</span><span class="o">)</span>

<span class="n">await</span><span class="o">(</span><span class="n">fut</span><span class="o">)</span>
<span class="c1">// ~~~&gt;[thread: 62] Fetching users List(1, 2, 3)
// &lt;~~~[thread: 62] Fetching users List(1, 2, 3)
</span>
<span class="c1">//=&gt;  List(User(1,@egg_1), User(2,@egg_2), User(3,@egg_3))
</span></code></pre></div>
<h2>scalaz</h2>

<p>There is still no integration with Scalaz, but soon will be.</p>
</div>


    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/languages/scala.min.js"></script>

  <script>
    jQuery(document).ready(function() {
      activeLinks();
      loadStyle();
      hljs.initHighlightingOnLoad();
      activeToggle();
      organizeContent();
      loadGitHubStats();
    });

    function loadStyle() {
      $("<link/>", {
        rel: "stylesheet",
        type: "text/css",
        href: "https://rawgit.com/47deg/microsites/cdn/fetch/palette.css"
      }).appendTo("head");
    }

    function organizeContent() {
      var content = $('#content');
      var subcontent = $('<div></div>');
      content.prepend(subcontent);

      content.find('h1').each(function(index) {
        var section = $('<section></section>');
        subcontent.append(section);
        var h1 = $(this);
        var elements = h1.nextUntil('h1');
        var text = h1.text();
        var slug = slugify(text) + '-' + index;
        addSectionToSidebar(text, slug);
        section.append(makeSectionAnchor(h1, text, slug));

        if (elements.length > 0) {
          elements.appendTo(section);
          organizeSubSection(slug, elements);

        }
      });

      removeEmptyList();
    }

    function organizeSubSection(s, children) {
      children.filter('h2').each(function(index, el) {
        var h2 = $(this);
        var text = h2.text();
        var slug = s + '-' + slugify(text) + '-' + index;
        var a = makeSectionAnchor(h2, text, slug);
        addSubSectionToSidebar(text, slug, s);

      });
    }

    function makeSectionAnchor(h, text, slug) {
      var a = $('<a></a>').attr({
        'class': 'anchor',
        'name': slug,
        'href': '#' + slug
      });
      a.append(h.clone());
      h.replaceWith(a);
      return a;
    }

    function addSectionToSidebar(text, slug) {
      var ul = $('<ul></ul>').addClass('sub_section');
      var a = $('<a href="#' + slug + '">' + text + '<span><i class="fa fa-angle-right"></i></span></a>');
      var li = $('<li class="' + slug + '"></li>');
      li.append(a).append(ul);
      $('#sidebar').append(li);

      a.click(function(event) {
        $('#sidebar li').add('#sidebar a').removeClass('active');
        $('#sidebar .sub_section').not(ul).slideUp();
        ul.slideToggle('fast');
        li.add(a).toggleClass('active');

      });
    }

    function addSubSectionToSidebar(text, slug, s) {
      var ul = $('#sidebar li.' + s + ' ul');
      var li = $('<li class="' + slug + '"><a href="#' + slug + '">' + text + '</a></li>');
      ul.append(li);
    }

    function removeEmptyList() {
      $('#sidebar>li').not('.sidebar-brand').each(function(index, el) {
        var li = $(this);
        var children = li.find('li');
        if (children.size() == 0) {
          li.find('span').remove();
        }
      });
    }

    function slugify(text) {
      return text.toString().toLowerCase()
        .replace(/\s+/g, '-') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/\-\-+/g, '-') // Replace multiple - with single -
        .replace(/^-+/, '') // Trim - from start of text
        .replace(/-+$/, ''); // Trim - from end of text
    }

    function activeToggle() {
      $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
      });
    }

    function activeLinks() {
      $('a[data-href]').each(function(index, el) {
        $(this).attr('href', $(this).attr('data-href'));
      });
    }

    var baseURL = window.location.href;

    function shareSiteFacebook() {
      var title = 'Fetch: Simple & Efficient data access for Scala(.js)';
      launchPopup('http://www.facebook.com/sharer/sharer.php?u='+baseURL+'&t=' + title);
    }

    function shareSiteTwitter() {
      var text = 'Fetch: Simple & Efficient data access for Scala(.js) '+baseURL;
      launchPopup('https://twitter.com/home?status=' + text);
      return false;
    }

    function shareSiteGoogle() {
      launchPopup('https://plus.google.com/share?url='+baseURL);
      return false;
    }

    function launchPopup(url) {
      window.open(url, 'Social Share', 'height=320, width=640, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, directories=no, status=no');
    }

    function loadGitHubStats() {

      var gitHubAPI = "https://api.github.com/repos/" + "47deg/fetch" + "?callback=?";
      $.getJSON(gitHubAPI).done(function(data) {
        $('#eyes').text(data.data.subscribers_count);
        $('#stars').text(data.data.stargazers_count);
      });

    }
  </script>

</body>










</html>


<!-- https://cdn.rawgit.com/47deg/microsites/cdn/docs.html -->
<!-- https://rawgit.com/47deg/microsites/cdn/docs.html -->
<!-- http://localhost/~rafaparadela/cdn47/microsites/docs.html -->
