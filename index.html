<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>Fetch</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Simple &amp; Efficient data access for Scala and Scala.js" /><meta name="author" content="47 Degrees" /><meta name="og:image" content="/fetch/img/poster.png" /><meta name="og:title" content="Fetch" /><meta name="og:site_name" content="Fetch" /><meta name="og:url" content="http://47deg.github.io/fetch/" /><meta name="og:type" content="website" /><meta name="og:description" content="Simple &amp; Efficient data access for Scala and Scala.js" /><meta name="twitter:image" content="/fetch/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/fetch/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/fetch/highlight/styles/tomorrow.css" /><link rel="stylesheet" href="/fetch/css/style.css" /><link rel="stylesheet" href="/fetch/css/palette.css" /></head><body><header id="site-header"><div class="navbar-wrapper"><div class="container"><div class="row"><div class="col-xs-6"><a href="/fetch/" class="brand"><div class="icon-wrapper"><span>Fetch</span></div></a></div><div class="col-xs-6"><nav class="text-right"><ul class=""><li><a href="https://github.com/47deg/fetch"><i class="fa fa-github"></i><span class="hidden-xs">GitHub</span></a></li><li><a href="/fetch/docs.html"><i class="fa fa-file-text"></i><span class="hidden-xs">Documentation</span></a></li></ul></nav></div></div></div></div><div class="jumbotron"><div class="container"><h1 class="text-center">Simple &amp; Efficient data access for Scala and Scala.js</h1><h2></h2><p class="text-center"><a href="https://github.com/47deg/fetch" class="btn btn-outline-inverse">View on GitHub</a></p></div></div><div><ul class="horizontalNav">        </ul></div></header><main id="site-main"><section class="use"><div class="container"><div id="content"><h2 id="installation">Installation</h2>

<p>Add the following dependency to your project’s build file.</p>

<p>For Scala 2.11.x and 2.12.x:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="s">"com.47deg"</span> <span class="o">%%</span> <span class="s">"fetch"</span> <span class="o">%</span> <span class="s">"0.6.0"</span>
</code></pre>
</div>

<p>Or, if using Scala.js (0.6.x):</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="s">"com.47deg"</span> <span class="o">%%%</span> <span class="s">"fetch"</span> <span class="o">%</span> <span class="s">"0.6.0"</span>
</code></pre>
</div>

<h2 id="remote-data">Remote data</h2>

<p>Fetch is a library for making access to data both simple &amp; efficient. Fetch is especially useful when querying data that
has a latency cost, such as databases or web services.</p>

<h2 id="define-your-data-sources">Define your data sources</h2>

<p>To tell Fetch how to get the data you want, you must implement the <code class="highlighter-rouge">DataSource</code> typeclass. Data sources have <code class="highlighter-rouge">fetchOne</code> and <code class="highlighter-rouge">fetchMany</code> methods that define how to fetch such a piece of data.</p>

<p>Data Sources take two type parameters:</p>

<ol>
<li><code>Identity</code> is a type that has enough information to fetch the data</li>
<li><code>Result</code> is the type of data we want to fetch</li>
</ol>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>

<span class="k">trait</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]{</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="n">fetchOne</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Identity</span><span class="o">)</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Result</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">fetchMany</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Identity</span><span class="o">])</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Identity</span>, <span class="kt">Result</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Note that when we create a query we can compute its result right away, defer its evaluation or make it asynchronous. Returning <code class="highlighter-rouge">Query</code> instances from the fetch methods allows us to abstract from the target result type and to run it synchronously or asynchronously.</p>

<p>We’ll implement a dummy data source that can convert integers to strings. For convenience, we define a <code class="highlighter-rouge">fetchString</code> function that lifts identities (<code class="highlighter-rouge">Int</code> in our dummy data source) to a <code class="highlighter-rouge">Fetch</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">fetch._</span>

<span class="k">implicit</span> <span class="k">object</span> <span class="nc">ToStringSource</span> <span class="k">extends</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"ToString"</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fetchOne</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Query</span><span class="o">.</span><span class="n">sync</span><span class="o">({</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[${Thread.currentThread.getId}] One ToString $id"</span><span class="o">)</span>
      <span class="nc">Option</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
    <span class="o">})</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fetchMany</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Query</span><span class="o">.</span><span class="n">sync</span><span class="o">({</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[${Thread.currentThread.getId}] Many ToString $ids"</span><span class="o">)</span>
      <span class="n">ids</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="n">toString</span><span class="o">)).</span><span class="n">toMap</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">fetchString</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="c1">// or, more explicitly: Fetch(n)(ToStringSource)
</span></code></pre>
</div>

<h2 id="creating-and-running-a-fetch">Creating and running a fetch</h2>

<p>Now that we can convert <code class="highlighter-rouge">Int</code> values to <code class="highlighter-rouge">Fetch[String]</code>, let’s try creating a fetch.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">fetchOne</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">fetchString</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</code></pre>
</div>

<p>We’ll run our fetches to the ambient <code class="highlighter-rouge">Id</code> monad in our examples, let’s do some imports.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Id</span>
<span class="k">import</span> <span class="nn">fetch.unsafe.implicits._</span>
<span class="k">import</span> <span class="nn">fetch.syntax._</span>
</code></pre>
</div>

<p>Note that in real-life scenarios you’ll want to run a fetch to a concurrency monad, synchronous execution of a fetch
is only supported in Scala and not Scala.js and is meant for experimentation purposes.</p>

<p>Let’s run it and wait for the fetch to complete:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">fetchOne</span><span class="o">.</span><span class="n">runA</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>
<span class="c1">// [46] One ToString 1
// res2: cats.Id[String] = 1
</span></code></pre>
</div>

<p>As you can see in the previous example, the <code class="highlighter-rouge">ToStringSource</code> is queried once to get the value of 1.</p>

<h2 id="batching">Batching</h2>

<p>Multiple fetches to the same data source are automatically batched. For illustrating it, we are going to compose three independent fetch results as a tuple.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.cartesian._</span>

<span class="k">val</span> <span class="n">fetchThree</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">(</span><span class="n">fetchString</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">fetchString</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">fetchString</span><span class="o">(</span><span class="mi">3</span><span class="o">)).</span><span class="n">tupled</span>
</code></pre>
</div>

<p>When executing the above fetch, note how the three identities get batched and the data source is only queried once.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">fetchThree</span><span class="o">.</span><span class="n">runA</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>
<span class="c1">// [46] Many ToString NonEmptyList(1, 2, 3)
// res4: cats.Id[(String, String, String)] = (1,2,3)
</span></code></pre>
</div>

<h2 id="parallelism">Parallelism</h2>

<p>If we combine two independent fetches from different data sources, the fetches can be run in parallel. First, let’s add a data source that fetches a string’s size.</p>

<p>This time, instead of creating the results with <code class="highlighter-rouge">Query#sync</code> we are going to do it with <code class="highlighter-rouge">Query#async</code> for emulating an asynchronous data source.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">object</span> <span class="nc">LengthSource</span> <span class="k">extends</span> <span class="nc">DataSource</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"Length"</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fetchOne</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Query</span><span class="o">.</span><span class="n">async</span><span class="o">((</span><span class="n">ok</span><span class="o">,</span> <span class="n">fail</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[${Thread.currentThread.getId}] One Length $id"</span><span class="o">)</span>
      <span class="n">ok</span><span class="o">((</span><span class="nc">Option</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">size</span><span class="o">)))</span>
    <span class="o">})</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fetchMany</span><span class="o">(</span><span class="n">ids</span><span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Query</span><span class="o">.</span><span class="n">async</span><span class="o">((</span><span class="n">ok</span><span class="o">,</span> <span class="n">fail</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"[${Thread.currentThread.getId}] Many Length $ids"</span><span class="o">)</span>
      <span class="n">ok</span><span class="o">(</span><span class="n">ids</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="o">)).</span><span class="n">toMap</span><span class="o">)</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">fetchLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Fetch</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre>
</div>

<p>And now we can easily receive data from the two sources in a single fetch.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">fetchMulti</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">(</span><span class="n">fetchString</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">fetchLength</span><span class="o">(</span><span class="s">"one"</span><span class="o">)).</span><span class="n">tupled</span>
</code></pre>
</div>

<p>Note how the two independent data fetches run in parallel, minimizing the latency cost of querying the two data sources.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">fetchMulti</span><span class="o">.</span><span class="n">runA</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>
<span class="c1">// [46] One ToString 1
// [60] One Length one
// res6: cats.Id[(String, Int)] = (1,3)
</span></code></pre>
</div>

<h2 id="caching">Caching</h2>

<p>When fetching an identity, subsequent fetches for the same identity are cached. Let’s try creating a fetch that asks for the same identity twice.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">fetchTwice</span><span class="k">:</span> <span class="kt">Fetch</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">one</span> <span class="k">&lt;-</span> <span class="n">fetchString</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">two</span> <span class="k">&lt;-</span> <span class="n">fetchString</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">two</span><span class="o">)</span>
</code></pre>
</div>

<p>While running it, notice that the data source is only queried once. The next time the identity is requested it’s served from the cache.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">fetchTwice</span><span class="o">.</span><span class="n">runA</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>
<span class="c1">// [46] One ToString 1
// res7: cats.Id[(String, String)] = (1,1)
</span></code></pre>
</div>

<hr />

<p>For more in-depth information take a look at our <a href="http://47deg.github.io/fetch/docs.html">documentation</a>.</p>
</div></div></section><section class="technologies"><div class="container"><div class="row">
            <div class="col-md-4"><div class="first-icon-wrapper"></div><h3>Scala</h3><p>Fetch is written in Scala and supports both Scala (JVM) and Scala.js (JavaScript environments)</p></div>
          
            <div class="col-md-4"><div class="second-icon-wrapper"></div><h3>Cats</h3><p>Fetch uses cats' Free Monad implementation as well as some of its data types.</p></div>
          
            <div class="col-md-4"><div class="third-icon-wrapper"></div><h3>Functional Programming</h3><p>Fetch is implemented using the Free Monad and Interpreter pattern.</p></div>
          </div></div></section></main><footer id="site-footer"><div class="container"><div class="row"><div class="col-xs-6"><p>Fetch is designed and developed by <a href="http://47deg.github.io/fetch/" target="_blank">47 Degrees</a></p></div><div class="col-xs-6"><p class="text-right"><a href="https://github.com/47deg/fetch"><span class="fa fa-github"></span>View on Github</a></p></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/fetch/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/fetch/js/automenu.js"></script></body></html>